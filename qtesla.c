// Adapted from qTesla
/*************************************************************************************
* qTESLA: an efficient post-quantum signature scheme based on the R-LWE problem
*
* Abstract: sampling functions
**************************************************************************************/

#include "fastrandombytes.h"
#include <stdint.h>
#include <stdio.h>
#include "cpucycles.h"
#include "randombytes.h"

#define round_double(x)   (uint64_t)(x+0.5)

#define CRYPTO_RANDOMBYTES 32
#define PARAM_Xi 254
#define PARAM_N 1024

#define BENCHMARK_ITERATION 1000

static inline uint32_t Bernoulli(int64_t r, int64_t t)
{ // Sample a bit from Bernoulli
  // Restriction: 25-bit exponent
    static const double exp[5][32] = {
    {
       1.00000000000000000000000000000,
       0.999989256254928157739376652784,
       0.999978512625284373647488167451,
       0.999967769111067407594703441334,
       0.999957025712276019464715008378,
       0.999946282428908969154538895997,
       0.999935539260965016574514481924,
       0.999924796208442921648304351076,
       0.999914053271341444312894152407,
       0.999903310449659344518592455767,
       0.999892567743395382229030608774,
       0.999881825152548317421162593665,
       0.999871082677116910085264884168,
       0.999860340317099920224936302369,
       0.999849598072496107857097875577,
       0.999838855943304233011992693194,
       0.999828113929523055733185763587,
       0.999817372031151336077563870963,
       0.999806630248187834115335432238,
       0.999795888580631309930030353919,
       0.999785147028480523618499888977,
       0.999774405591734235290916493723,
       0.999763664270391205070773684699,
       0.999752923064450193094885895547,
       0.999742181973909959513388333904,
       0.999731440998769264489736838277,
       0.999720700139026868200707734937,
       0.999709959394681530836397694805,
       0.999699218765732012600223590339,
       0.999688478252177073708922352427,
       0.999677737854015474392550827280,
       0.999666997571245974894485633327,
    },
    {
       1.00000000000000000000000000000,
       0.999656257403867335471423018110,
       0.999312632966707066966960954156,
       0.998969126647902922558836634427,
       0.998625738406852591862030569602,
       0.998282468202967721235104001204,
       0.997939315995673908982671629602,
       0.997596281744410700559523456495,
       0.997253365408631583776395175000,
       0.996910566947803984007386540671,
       0.996567886321409259399027156979,
       0.996225323488942696080989108946,
       0.995882878409913503378445878858,
       0.995540551043844809026076978151,
       0.995198341350273654383717729771,
       0.994856249288750989653653635502,
       0.994514274818841669099558762936,
       0.994172417900124446267077586982,
       0.993830678492191969206049720982,
       0.993489056554650775694376972690,
       0.993147552047121288463532160602,
       0.992806164929237810425709126275,
       0.992464895160648519902613378490,
       0.992123742701015465855892805309,
       0.991782707510014563119207890260,
       0.991441789547335587631940869085,
       0.991100988772682171674543263671,
       0.990760305145771799105521230002,
       0.990419738626335800600058157116,
       0.990079289174119348890273954307,
       0.989738956748881454007120463947,
       0.989398741310394958523912437530,
    },
    {
       1.00000000000000000000000000000,
       0.989058642818446532801493512736,
       0.978236998933867397234361985613,
       0.967533758520321015752254698405,
       0.956947626083139283273339858119,
       0.946477320302123985251548239278,
       0.936121573876458859745046330076,
       0.925879133371318532008168908245,
       0.915748759066155755518440313060,
       0.905729224804648596488518008357,
       0.895819317846289399828488709190,
       0.886017838719597573241254715819,
       0.876323601076938422676818431761,
       0.866735431550930466763895441537,
       0.857252169612423850102989807579,
       0.847872667430032665467120796179,
       0.838595789731204183037814820589,
       0.829420413664808170827534922167,
       0.820345428665229674427928445069,
       0.811369736317948806198401190051,
       0.802492250226591273993599093479,
       0.793711895881433557543181211048,
       0.785027610529346816664346978850,
       0.776438343045163789628247116200,
       0.767943053804453112236738695573,
       0.759540714557685658516787788394,
       0.751230308305777672426796560728,
       0.743010829176995626612629001003,
       0.734881282305207909071300744040,
       0.726840683709468601597133154191,
       0.718888060174918775118381113904,
       0.711022449134990886501443115247,
    },
    {
       1.00000000000000000000000000000,
       0.703242898554902019124053029907,
       0.494550574367900212377617199343,
       0.347789179400473775802958963432,
       0.244580270607619998547495547642,
       0.171999338431444994659372177169,
       0.120957313308054932555461572431,
       0.0850623716121699748959577141675,
       0.0598195087704966269734942003671,
       0.0420676447378944310518226079032,
       0.0295837724208547511157958833540,
       0.0208045778674304658613798062912,
       0.0146306716427029628915075520239,
       0.0102889159338194414126871303468,
       0.00723560706428690041407336112977,
       0.00508838928469344512019141328006,
       0.00357837362954352287609295639116,
       0.00251646584335261219672687255311,
       0.00176968673379369701462942941814,
       0.00124451962820723676450112134430,
       0.000875199590648926181371623560108,
       0.000615477896942014568363487986594,
       0.000432830460241977590753508116949,
       0.000304384947443420598499221575521,
       0.000214056552716592614648809884875,
       0.000150533750587086776320197856296,
       0.000105861791093203588103984771767,
       7.44465528145980010279519403986E-5,
       5.23540095887584974215497854572E-5,
       3.68175854541696595788983222161E-5,
       2.58917055125830700937290248609E-5,
       1.82081580331988533459488510884E-5,
    },
    {
       1.00000000000000000000000000000,
       1.28047578326124854944339565224E-5,
       1.63961823151850797088054332854E-10,
       2.09949143925308465763016078730E-15,
       2.68834794512787960521796244519E-20,
       3.44236444071638967368499330455E-25,
       4.40786430349698886513758904620E-30,
       5.64416349652960461066124757137E-35,
       7.22721467407329277280659442666E-40,
       9.25427337058118871276543632686E-45,
       1.18498729427086622762660635910E-49,
       1.51734753378611505864555303848E-54,
       1.94292677180429947645039178125E-59,
       2.48787067994535949568291811017E-64,
       3.18565815755572920378954929719E-69,
       4.07915812449875829104234432124E-74,
       5.22326319451403314822573066392E-79,
       6.68826203017500783289016564369E-84,
       8.56415756174481153553172932321E-89,
       1.09661963618479321373579435764E-93,
       1.40419488758338851229584913702E-98,
       1.79803754852978026059222482476E-103,
       2.30234353828680557939793733415E-108,
       2.94809514552427176254614549482E-113,
       3.77496444059387641104039813827E-118,
       4.83375054885280486673773338171E-123,
       6.18950052013178538274122267097E-128,
       7.92550552651165318381709362615E-133,
       1.01484178968013631915794210078E-137,
       1.29948033552691981828897903693E-142,
       1.66395310046642272458842303649E-147,
       2.13065164962972563731504807067E-152,
    },
    };
  // assert(t >= 0 && t < (1LL << 25));

    // Compute the actual Bernoulli parameter c = exp(-t/f):
    double c = 4611686018427387904.0;  // This yields a fraction of 2^62, to keep only 62 bits of precision in this implementation

    for (int64_t i = 0, s = t; i < 5; i++, s >>= 5) {
        c *= exp[i][s & 31]; 
    }
    // Sample from Bernoulli_c
    return (uint32_t)((uint64_t)((r & 0x3FFFFFFFFFFFFFFFLL) - round_double(c)) >> 63);
}


void sample_gauss_poly(int32_t *x, const unsigned char *seed, int nonce)
{ // Gaussian sampler
  static const int64_t cdt[12][2] = {
   {0x0200000000000000LL, 0x0000000000000000LL},
   {0x0300000000000000LL, 0x0000000000000000LL},
   {0x0320000000000000LL, 0x0000000000000000LL},
   {0x0321000000000000LL, 0x0000000000000000LL},
   {0x0321020000000000LL, 0x0000000000000000LL},
   {0x0321020100000000LL, 0x0000000000000000LL},
   {0x0321020100200000LL, 0x0000000000000000LL},
   {0x0321020100200100LL, 0x0000000000000000LL},
   {0x0321020100200100LL, 0x0200000000000000LL},
   {0x0321020100200100LL, 0x0200010000000000LL},
   {0x0321020100200100LL, 0x0200010000200000LL},
   {0x0321020100200100LL, 0x0200010000200001LL}, 
  };  

  unsigned char seed_ex[PARAM_N*8]; 
  int64_t i, j=0, x_ind;
  int64_t *buf = (int64_t*)seed_ex;
  int64_t sign, k, bitsremained, rbits, y, z;
  uint64_t r, s;
  int16_t dmsp = (int16_t)(nonce<<8);

  fastrandombytes_setseed(seed);
  fastrandombytes(seed_ex, PARAM_N*8);

  for (x_ind=0; x_ind<PARAM_N; x_ind++){
    if ((j+46) > (PARAM_N)){
	  fastrandombytes((unsigned char *)buf, PARAM_N*8);
      j=0;
    }
    do {
      rbits=buf[j++]; bitsremained=64;
      do {
        // Sample x from D^+_{\sigma_2} and y from U({0, ..., k-1}):
        do {
          r = buf[j++];
          s = buf[j++];
          if (bitsremained <= 64 - 6) {
            rbits = (rbits << 6) ^ ((r >> 58) & 63); bitsremained += 6;
          }
          r &= 0x03FFFFFFFFFFFFFFLL;
        } while (r > 0x0321020100200100LL);  // Checking if r exceeds a maximum value. Variation is random and does not depend on private data
        y = 0;
        for (i = 0; i < 12; i++) {
          uint64_t c_lo = s - cdt[i][1];
          uint64_t b = (((c_lo & cdt[i][1]) & 1) + (cdt[i][1] >> 1) + (c_lo >> 1)) >> 63;
          uint64_t c_hi = r - (cdt[i][0] + b);
          y += ~(c_hi >> (63)) & 1LL; 
        }
        do {
          if (bitsremained < 8) {
            rbits = buf[j++]; bitsremained = 64;
          }
          z = rbits & 255; rbits >>= 8; bitsremained -= 8;
        } while (z >= PARAM_Xi);  // Making sure random z does not exceed a certain limit. No private data leaked, it varies uniformly
        k = PARAM_Xi*y + z;
        // Sample a bit from Bernoulli_{exp(-y*(y + 2*k*x)/(2*k^2*sigma_2^2))}
      } while (Bernoulli(buf[j++], z*((k << 1) - z)) == 0);
      // Put last randombits into sign bit
      rbits <<=(64-bitsremained);
      if (bitsremained==0LL) {
        rbits = buf[j++]; bitsremained=64;
      }
      sign = rbits >> 63; rbits <<= 1; bitsremained--;
    } while ((k | (sign & 1)) == 0);
    if (bitsremained==0LL) {
      rbits = buf[j++]; bitsremained=64;
    }
    sign = rbits >> 63; rbits <<= 1; bitsremained--;
    k = ((k << 1) & sign) - k;
    x[x_ind] = (int32_t)((k<<48)>>48);
  }
}

int main()
{
	int32_t sample[1024];
	unsigned char seed[32];
	long long cycle1[BENCHMARK_ITERATION], cycle2[BENCHMARK_ITERATION];
	uint32_t t, i;
	
	for (t = 0; t < BENCHMARK_ITERATION; t++)
	{
		printf("Iteration: %u\n", t);
		randombytes(seed, 32);	
		cycle1[t] = cpucycles();
		sample_gauss_poly(sample, seed, 0);
		cycle2[t] = cpucycles();
	
		for (i = 0; i < 1024; i++)
		{
			printf("%lld ", sample[i]);
		}	
		printf("\n");
	}
	
	printf("Cycles:\n");
	for (t = 0; t < BENCHMARK_ITERATION; t++)
	{
		printf("%lld\n", cycle2[t] - cycle1[t]);
	}
	
	return 0;
}
